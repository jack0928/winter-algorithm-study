# 11053: 가장 긴 증가하는 부분 수열
'''
10 5 20 15 30 25 27 인 경우에는 어떻게 되나
10
10 / 5
10 20 / 5 20
10 20 / 5 20 / 5 15 <- 이때 더 유망한 숫자인 15로 가야 하나?
10 20 30 / 5 20 30 / 5 15 30
10 20 30 / 5 20 30 / 5 15 30 / 5 15 25 <- 이때 더 유망한 숫자인 25로 가야 하나?
5 15 25 27
- 근데 배열이 중요한 게 아니라 길이만 알면 되지 않나? (길이는 적어도 줄어들지는 않는다)
: 1 > 2 > 2 > 3 > 3 > 4
- 그렇다면 언제 길이가 증가하는가?
: 직전 수보다 큰 수가 나왔을 때? (무조건인가? 도저히 반례를 못 떠올리겠어서 부딪혀봤는데 바로 틀림)

30
67 154 11 237 200 248 197 44 128 157 161 201 193 171 127 35 211 166 10 197 203 6 243 183 182 92 222 89 163 3
9 나와야하는데 14 나옴

그러면 dp[i]가 될 수 있는 건?
: num[i]로 끝나는 LIS의 최대 길이 or num[i]까지 들어왔을 때 LIS의 최대 길이
num[i]로 끝나는 LIS의 최대 길이로하면
10
5
10 20 / 5 20
10 15 / 5 15
10 20 30 / 5 20 30 / 5 15 30
5 15 25
5 15 25 27

num[i]까지 들어왔을 때 LIS의 최대 길이로 하면
10
10 / 5
10 20 / 5 20
10 20 / 5 20 / 5 15
10 20 30 / 5 20 30 / 5 15 30
10 20 30 / 5 20 30 / 5 15 30 / 5 15 25
5 15 25 27

둘 다 수열이 하나로 고정되지는 않는다.
그런데 전자는 수열은 맨 끝값은 고정된다.
그러면 어떻게 num[i]로 끝나는 수열을 만들 수 있을까?

dp[0] ~ dp[i-1] 중에서 num[i]가 들어갈 수 있는 애들, 즉 num[x]가 num[i]보다 작은 애들의 dp[x]에 1을 붙인 값들 중에 최대인 값
for i in range(n):
    for j in range(i): # dp[0] ~ dp[i-1] 중에서
        if num[i] > num[j]: # num[x]가 num[i]보다 작은 애들의
            dp[i] = max(dp[i], dp[j] + 1) # dp[x]에 1을 붙인 값들 중에 최대인 값

'''

n = int(input())
num = list(map(int, input().split()))
# dp[i] = num[i]로 끝나는 LIS의 최대 길이
dp = [1] * n

for i in range(n):
    for j in range(i): # dp[0] ~ dp[i-1] 중에서
        if num[i] > num[j]: # num[x]가 num[i]보다 작은 애들의
            dp[i] = max(dp[i], dp[j] + 1) # dp[x]에 1을 붙인 값들 중에 최대인 값

print(max(dp))






'''
3년 전에 풀었던 코드
import bisect

n=int(input())
num=list(map(int, input().split()))

ans=[num[0]]

for x in num[1:]:
    if x > ans[-1]:
         ans.append(x)
    else:
        ans[bisect.bisect_left(ans, x)] = x
print(len(ans))

이분 탐색 + 그리디로 LIS(최장 증가 부분 수열)의 길이만 구하는 방법
-> 어떻게 이런 생각을 했지? 시간 날 때 DP 방식과 비교해보기
'''