# 2110: 공유기 설치
'''
가장 인접한 두 공유기 사이의 거리를 최대한으로 늘리려면(저점을 높이려면)
-> 최대한 균등한 간격으로 배치해야 함
어떻게?
1. 1/c 지점에 가까운 애들로 배치?
[1,2,4,8,9]면 1+8(3+1), 1+(8/(3+1))*2 , 1+(8/(3+1))*3 해서 3,5,7 가까운 애들로 -> 2,4,8
근데 간격을 넓혀야 하니까 맨 처음과 맨 마지막은 무조건 양끝이 유리하다.

2. 그렇다면 맨 처음과 맨 마지막을 고르고 나머지는 1/(n-1) 지점?
[1,2,4,8,9]면 1,9 그리고 1/(3-1)인 5에 가까운 4? → 이러면 1,4,9가 나오긴 함
근데 최적해가 나오나?

[반례]
N = 5, C = 4, 집 좌표: [0, 1, 5, 7, 9]
→ 내 방식: [0, 1or5, 5or7, 9]
→ 최적해: [0, 5, 7, 9]: 이걸로 고정할 수 있나?
일단 아닌 것 같으니 다음 방법 고민

------------------------------------------------------------------------------------
3.실제로 배치하는 게 아닌가? 결국 구하는 건 거리니까 거리 중심으로 생각해보기
- DP로 풀기에는 넘겨야 할 정보가 너무 많고, i-1로 i가 결정되지 않는다.
- 특정 거리가 되는지 확인을 하고, 그에 따라 더 큰 값이나 작은 값 고려?
- 특정 거리 k가 되는지 확인할 수 있나?:
    단순하게 끝에서 부터 k씩 띄워서 공유기 설치했을 때 제일 먼 집보다 작거나 같으면 OK?
    -> 근데 해당 거리에 맞는 간격이 없다면? 1 3 6 9가 있고, C=3일 때 1 5 9를 하면 거리는 되는데 5가 없다.
    생각해보니 이걸 통해 k가 되는지는 모르지만

---------------------------------------------------
간격이 1인 경우 123
2인 경우 13 5
..
이런 식으로 간격을 늘리면서 가능한 지점을 찾는다.
그리고 큰 것부터 아래로도 내려오면서 찾는다.
그렇게 양방향을 비교하면서 이분 탐색
'''
n,c = map(int, input().split())
houses = []
for _ in range(n):
    house = int(input())
    houses.append(house)

houses.sort()


